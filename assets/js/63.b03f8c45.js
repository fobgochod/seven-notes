(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{631:function(v,_,t){"use strict";t.r(_);var l=t(17),a=Object(l.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"深入理解java虚拟机-第3版"}},[v._v("深入理解Java虚拟机（第3版）")]),v._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[v._v("书籍简介")]),v._v(" "),t("ul",[t("li",[v._v("本书作者为 [中] 周志明。")]),v._v(" "),t("li",[v._v("本书是《深入理解Java虚拟机》系列第3版。")]),v._v(" "),t("li",[v._v("这是一部从工作原理和工程实践两个维度深入剖析JVM的著作。")])])]),v._v(" "),t("h2",{attrs:{id:"rednaxelafx"}},[v._v("RednaxelaFX")]),v._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://www.zhihu.com/question/41922036/answer/93079526",target:"_blank",rel:"noopener noreferrer"}},[v._v("Major GC和Full GC的区别是什么"),t("OutboundLink")],1)]),v._v(" "),t("li",[t("a",{attrs:{href:"https://www.zhihu.com/question/48780091/answer/113063216",target:"_blank",rel:"noopener noreferrer"}},[v._v("JVM full GC的奇怪现象"),t("OutboundLink")],1)]),v._v(" "),t("li",[t("a",{attrs:{href:"https://www.zhihu.com/question/56344485/answer/149543993",target:"_blank",rel:"noopener noreferrer"}},[v._v("JVM默认老年代回收是 PSMarkSweep(Serial-Old) 还是Parallel Old"),t("OutboundLink")],1)])]),v._v(" "),t("h2",{attrs:{id:"走近java"}},[v._v("走近Java")]),v._v(" "),t("p",[t("img",{attrs:{src:"/images/jvm/jvm-6.png",alt:"Java技术发展时间线"}})]),v._v(" "),t("h2",{attrs:{id:"自动内存管理"}},[v._v("自动内存管理")]),v._v(" "),t("blockquote",[t("p",[v._v("Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。")])]),v._v(" "),t("blockquote",[t("p",[v._v("《Java虚拟机规范》规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区")])]),v._v(" "),t("p",[t("img",{attrs:{src:"/images/jvm/jvm-5.png",alt:"Java虚拟机运行时数据区"}})]),v._v(" "),t("ul",[t("li",[v._v("程序计数器\n"),t("ul",[t("li",[v._v("线程私有")]),v._v(" "),t("li",[v._v("如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址")]),v._v(" "),t("li",[v._v("如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）")]),v._v(" "),t("li",[v._v("唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域")])])]),v._v(" "),t("li",[v._v("Java虚拟机栈\n"),t("ul",[t("li",[v._v("线程私有，生命周期与线程相同")]),v._v(" "),t("li",[v._v("虚拟机栈描述的是Java方法执行的线程内存模型： 每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧￼（Stack\nFrame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。")]),v._v(" "),t("li",[v._v("变量槽（Slot）")]),v._v(" "),t("li",[v._v("如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常")]),v._v(" "),t("li",[v._v("如果Java虚拟机栈容量可以动态扩展￼，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常")])])]),v._v(" "),t("li",[v._v("本地方法栈\n"),t("ul",[t("li",[v._v("虚拟机栈为虚拟机执行执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到本地（Native）方法服务")]),v._v(" "),t("li",[v._v("譬如Hot-Spot虚拟机直接就把本地方法栈和虚拟机栈合二为一")]),v._v(" "),t("li",[v._v("与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常")])])]),v._v(" "),t("li",[v._v("Java堆（GC堆）\n"),t("ul",[t("li",[v._v("被所有线程共享")]),v._v(" "),t("li",[v._v('Java世界里"几乎"所有的对象实例都在这里分配内存')]),v._v(" "),t("li",[v._v("由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆中经常会出现“新生代”“老年代”“永久代”“Eden空间”“From Survivor空间”“To Survivor空间”等名词")]),v._v(" "),t("li",[v._v("在十年之前（以G1收集器的出现为分界），作为业界绝对主流的HotSpot虚拟机，它内部的垃圾收集器全部都基于“经典分代”￼来设计，需要新生代、老年代收集器搭配才能工作")]),v._v(" "),t("li",[v._v("Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）")]),v._v(" "),t("li",[v._v("如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常")])])]),v._v(" "),t("li",[v._v("方法区（Method Area）\n"),t("ul",[t("li",[v._v("被所有线程共享")]),v._v(" "),t("li",[v._v("在JDK 6的时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计划了")]),v._v(" "),t("li",[v._v("到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出")]),v._v(" "),t("li",[v._v("而到了JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Meta-space）来代替，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。")]),v._v(" "),t("li",[v._v("根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常")])])]),v._v(" "),t("li",[v._v("运行时常量池（Runtime Constant Pool）\n"),t("ul",[t("li",[v._v("是方法区的一部分")]),v._v(" "),t("li",[v._v("当常量池无法再申请到内存时会抛出OutOfMemoryError异常")])])]),v._v(" "),t("li",[v._v("直接内存（Direct Memory）\n"),t("ul",[t("li",[v._v("并不是虚拟机运行时数据区的一部分")]),v._v(" "),t("li",[v._v("但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现")])])])]),v._v(" "),t("h3",{attrs:{id:"hotspot虚拟机对象探秘"}},[v._v("HotSpot虚拟机对象探秘")]),v._v(" "),t("ul",[t("li",[v._v("给对象分配内存\n"),t("ul",[t("li",[v._v("指针碰撞（Bump The Pointer）")]),v._v(" "),t("li",[v._v("空闲列表（Free List）")])])]),v._v(" "),t("li",[v._v("本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）")]),v._v(" "),t("li",[v._v("对象的访问定位\n"),t("ul",[t("li",[v._v("句柄访问")]),v._v(" "),t("li",[v._v("直接指针")])])])]),v._v(" "),t("h3",{attrs:{id:"经典垃圾收集器"}},[v._v("经典垃圾收集器")]),v._v(" "),t("h4",{attrs:{id:"术语"}},[v._v("术语")]),v._v(" "),t("ul",[t("li",[v._v("垃圾收集器（Garbage Collection，简称GC）")]),v._v(" "),t("li",[v._v("判断对象是否存活算法\n"),t("ul",[t("li",[v._v("引用计数算法（Reference Counting）：微软COM技术（Component Object Model）")]),v._v(" "),t("li",[v._v("可达性分析算法（Reachability Analysis）：主流Java虚拟机\n"),t("ul",[t("li",[v._v("字符串常量池（String Table）")]),v._v(" "),t("li",[v._v("GC Roots集合")])])])])]),v._v(" "),t("li",[v._v("分代收集和局部回收(Partial GC)")]),v._v(" "),t("li",[v._v("从如何判定对象消亡的角度出发，垃圾收集算法可分为\n"),t("ul",[t("li",[v._v("引用计数式垃圾收集（Reference Counting GC），又称：直接垃圾收集")]),v._v(" "),t("li",[v._v("追踪式垃圾收集（Tracing GC），又称：间接垃圾收集")])])]),v._v(" "),t("li",[v._v('当前商业虚拟机的垃圾收集器大多遵循了"分代收集"（Generational Collection）的理论进行设计\n'),t("ul",[t("li",[v._v("两个分代假说\n"),t("ul",[t("li",[v._v("弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的")]),v._v(" "),t("li",[v._v("强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡")])])]),v._v(" "),t("li",[v._v("第三条经验法则\n"),t("ul",[t("li",[v._v("跨代引用假说（Intergenerational Reference Hypothesis）：夸代引用相对于同代引用来说仅占极少数")])])])])]),v._v(" "),t("li",[v._v("Java堆划分区域\n"),t("ul",[t("li",[v._v("新生代（Young Generation）和老年代（Old Generation）：HotSpot虚拟机，也是现代业界主流命名方式")]),v._v(" "),t("li",[v._v("婴儿区（Nursery）和长存区（Tenured）：IBM J9虚拟机")])])]),v._v(" "),t("li",[v._v("分代统一定义\n"),t("ul",[t("li",[v._v("部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：\n"),t("ul",[t("li",[v._v("新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。")]),v._v(" "),t("li",[v._v("老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major\nGC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。")]),v._v(" "),t("li",[v._v("混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。")])])]),v._v(" "),t("li",[v._v("整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。")])])]),v._v(" "),t("li",[v._v("垃圾收集器算法\n"),t("ul",[t("li",[v._v("标记-清除算法（Mark-Sweep）")]),v._v(" "),t("li",[v._v("标记-复制算法\n"),t("ul",[t("li",[v._v("半区复制（Semispace Coping）")]),v._v(" "),t("li",[v._v("分配担保（Handle Promotion）")])])]),v._v(" "),t("li",[v._v("标记-整理算法（Mark-Compact）")])])]),v._v(" "),t("li",[v._v("并发标记对象消失问题\n"),t("ul",[t("li",[v._v('两个条件同时满足，才会产生"对象消失"问题\n'),t("ul",[t("li",[v._v("赋值器插入了一条或多条从黑色对象到白色对象的新引用；")]),v._v(" "),t("li",[v._v("赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。")])])]),v._v(" "),t("li",[v._v("两种解决方案\n"),t("ul",[t("li",[v._v("增量更新（Incremental Update）：CMS")]),v._v(" "),t("li",[v._v("原始快照（Snapshot At The Beginning，SATB）：G1、Shenandoah")])])])])]),v._v(" "),t("li",[v._v("衡量垃圾收集器的三项最重要的指标（不可能三角）\n"),t("ul",[t("li",[v._v("内存占用（Footprint）")]),v._v(" "),t("li",[v._v("吞吐量（Throughput）")]),v._v(" "),t("li",[v._v("延迟（Latency）")])])])]),v._v(" "),t("h4",{attrs:{id:"垃圾收集器"}},[v._v("垃圾收集器")]),v._v(" "),t("blockquote",[t("p",[v._v('"经典"：指在JDK 7 Update 4之后（在这个版本中正式提供了商用的G1收集器，此前G1仍处于实验状态）、\nJDK 11正式发布之前，OracleJDK中的HotSpot虚拟机所包含的全部可用的垃圾收集器。')])]),v._v(" "),t("blockquote",[t("p",[v._v("注意：并行和并发都是并发编程中的专业名词，在谈论垃圾收集器的上下文语境中，它们可以理解为")]),v._v(" "),t("ul",[t("li",[v._v("并行（Parallel）：并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态。")]),v._v(" "),t("li",[v._v("并发（Concurrent）：并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行。由于用户线程并未被冻结，所以程序仍然能响应服务请求，但由于垃圾收集器线程占用了一部分系统资源，此时应用程序的处理的吞吐量将受到一定影响。")])])]),v._v(" "),t("p",[t("img",{attrs:{src:"/images/jvm/jvm-2.png",alt:""}}),v._v(" "),t("img",{attrs:{src:"/images/jvm/jvm-3.png",alt:""}})]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("垃圾收集器")]),v._v(" "),t("th",[v._v("区域")]),v._v(" "),t("th",[v._v("算法")]),v._v(" "),t("th",[v._v("GC线程")]),v._v(" "),t("th",[v._v("描述")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("Serial")]),v._v(" "),t("td",[v._v("新生代")]),v._v(" "),t("td",[v._v("标记-复制")]),v._v(" "),t("td",[v._v("单线程(STW)")]),v._v(" "),t("td",[v._v("1. JDK1.3.1之前HotSpot新生代唯一选择"),t("br"),v._v("2. HotSpot客户端模式下默认的新生代收集器"),t("br"),v._v("3. 简单高效(与其他收集器单线程相比)，它是收集器额外内存消耗(Memory Footprint)最小的")])]),v._v(" "),t("tr",[t("td",[v._v("ParNew")]),v._v(" "),t("td",[v._v("新生代")]),v._v(" "),t("td",[v._v("标记-复制")]),v._v(" "),t("td",[v._v("多线程并行(STW)")]),v._v(" "),t("td",[v._v("1. Serial多线程并行版本，其余行为包括控制参数、收集算法、STW、对象分配规、回收策略等都与Serial完全一致"),t("br"),v._v("2. JDK7之前遗留系统中首选的新生代收集器"),t("br"),v._v("3. 除了Serial收集器外，目前只有它能与CMS配合工作")])]),v._v(" "),t("tr",[t("td",[v._v("Parallel Scavenge")]),v._v(" "),t("td",[v._v("新生代")]),v._v(" "),t("td",[v._v("标记-复制")]),v._v(" "),t("td",[v._v("多线程并行(STW)")]),v._v(" "),t("td",[v._v('1. 目标是达到一个可控制的吞吐量(Throughput)，被称作"吞吐量优先收集器"'),t("br"),v._v("2. -XX:+MaxGCPauseMillis：控制最大垃圾收集停顿时间，大于0毫秒"),t("br"),v._v("3. -XX：GCTimeRatio：直接设置吞吐量大小，大于0小于100的整数"),t("br"),v._v("4. -XX:+UseAdaptiveSizePolicy：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。这种调节方式称为垃圾收集的自适应的调节策略（GC Ergonomics）")])]),v._v(" "),t("tr",[t("td",[v._v("Serial Old (MSC)(MarkSweepCompact)")]),v._v(" "),t("td",[v._v("老年代")]),v._v(" "),t("td",[v._v("标记-整理")]),v._v(" "),t("td",[v._v("单线程(STW)")]),v._v(" "),t("td",[v._v("1. 是Serial收集器老年代版本"),t("br"),v._v("2. 主要意义是提供客户端模式下HotSpot虚拟机使用"),t("br"),v._v("3. JDK5之前与Parallel Scavenge搭配使用"),t("br"),v._v("4. 作为CMS收集器发生失败时的后备预案")])]),v._v(" "),t("tr",[t("td",[v._v("Parallel Old")]),v._v(" "),t("td",[v._v("老年代")]),v._v(" "),t("td",[v._v("标记-整理")]),v._v(" "),t("td",[v._v("多线程并发(STW)")]),v._v(" "),t("td",[v._v("1. JDK6才开始提供，Parallel Scavenge收集器的老年代版本"),t("br"),v._v("2. 吞吐量优先(Parallel Scavenge+Parallel Old)")])]),v._v(" "),t("tr",[t("td",[v._v("CMS (Concurrent Mark Sweep)")]),v._v(" "),t("td",[v._v("老年代")]),v._v(" "),t("td",[v._v("标记-清除")]),v._v(" "),t("td",[v._v("并发标记、并发清除")]),v._v(" "),t("td",[v._v("1. 四个步骤，1)初始标记 2)并发标记(增量更新) 3)重新标记 4)并发清除"),t("br"),v._v('2. "并发低停顿收集器"，是HotSpot虚拟机追求低停顿的第一次成功尝试'),t("br"),v._v("3. 只有CMS会有单独收集老年代的行为"),t("br"),v._v('4. 三个明显缺点，1)对资源非常敏感，应为占用一部分线程而导致应用程序变慢，降低吞吐量 2) 无法处理"浮动垃圾"(Floating Garbage) 3)"标记-清除"算法必然会带来空间碎片')])]),v._v(" "),t("tr",[t("td",[v._v("G1 (Garbage First)")]),v._v(" "),t("td",[v._v("Region")]),v._v(" "),t("td",[v._v("标记-整理、标记-复制")]),v._v(" "),t("td",[v._v("并发标记")]),v._v(" "),t("td",[v._v("1. 垃圾收集器技术发展历史上里程牌式的成功"),t("br"),v._v("2.基于Region的内存布局"),t("br"),v._v("3. JDK 7 Update 4正式提供商用")])]),v._v(" "),t("tr",[t("td",[v._v("Shenandoah")]),v._v(" "),t("td",[v._v("Region")]),v._v(" "),t("td"),v._v(" "),t("td",[v._v("并发标记、并发整理")]),v._v(" "),t("td",[v._v("是一款只有OpenJDK才会包含，而OracleJDK里反而不存在的收集器")])]),v._v(" "),t("tr",[t("td",[v._v("ZGC")]),v._v(" "),t("td",[v._v("Region")]),v._v(" "),t("td"),v._v(" "),t("td",[v._v("并发整理")]),v._v(" "),t("td",[v._v("2018年Oracle创建JEP333将ZGC提交给OpenJDK，推动其进入OpenJDK发布清单之中")])])])]),v._v(" "),t("h3",{attrs:{id:"垃圾收集相关常用参数"}},[v._v("垃圾收集相关常用参数")]),v._v(" "),t("p",[t("img",{attrs:{src:"/images/jvm/jvm-4.png",alt:""}})])])}),[],!1,null,null,null);_.default=a.exports}}]);